será usado o Jetstream q já contém o Sanctum
O jetstream já gera uma rota web

    composer require laravel/jetstream

    "php artisan jetstream:install livewire" que criará a migration para relacionar o usuário ao token gerado

    "npm install" - cria a build das views

    "npm run dev" - executa

    "php artisan migrate"


foi criada uma collection no postman chamada teste_sanctum e uma request chamada autenticacao

// foi criada uma rota chamada autenticator

criar controller de autenticação. No caso se chama AuthController

no AuthController, é preciso importar o Hash e Validation e a model User

foi feita a função 'login()'

subiu o server

foi feito um cadastro de usuário "alvaro220592@gmail.com" e senha "12345678" la no frontend em 'register'

vai nas rotas (lá já tem um middleware gerado pelo sanctum)
lá foi criada uma rota pro login:
    "Route::post('/authenticator', [AuthController::class, 'login']);"

essa rota foi testada no postman e deu certo

foi criada uma variavel la no postman chamada AccessToken sem valor
na aba 'tests' foi feito um test script pra variavel receber o valor do token quando ele for gerado.
nomes: "pm" = postman

foi criado um novo request chamado USER aproveitando a rota 'user' criada automaticamente pelo sanctum

clica em Autorization e seleciona o tipo 'bearer token'. No campo 'token', coloca o nome da variável q foi criadda valendo nada chamada AccessToken entre 2 chaves{{}}

Quando fizer uma request de login de novo, ao passar o cursor em cima da variavel no campo de token, aparece o valor dela la

faz uma requisição get na rota users pra testar

foi criada uma rota de logout
foi feita uma rota middleware pra abrigar as rotas q precisem de autenticação

foi criada a rota e a função logout
pra rodar a rota logout no postman, precisa selecionar de novo o bearer token na aba Autorization e a variavel AccessToken tem q estar lá
SAVE
Roda pra testar

Se nao estiver logado e mandar uma request, o postman retorna a pagina welcome

pra SEMPRE retornar uma resposta json, precisa ir no Headers, colocar 'Accept' em keys e "application/json" no value. Como nem todo mundo q rodar a api vai se atentar a isso, tem a dica:
forçar com q qualquer equisição q venha da api, seja já considerada como json automaticamente. Pra isso foi criado um middleware chamado JsonResponseMiddleware

la no middleware importa "use Illuminate\Http\JsonResponse" e "use Illuminate\Routing\ResponseFactory"
dentro da classe foi declarada uma var protected e um metodo construtor

na função handle foi feito o 'preset' do header q seria feito no postman
depois do middleware configurado, vai em kernel e em $middlewareGroups, importa o middleware criado
